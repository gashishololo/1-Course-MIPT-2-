class Matrix:
    def __init__(self, other):
        if len(other) == 0: raise ValueError('Недостаточно параметров')
        if type(other[0]) not in [list, tuple]:
            if len(other) != 2:
                raise ValueError('Вместо {} нужно два параметра'.format(len(other)))
            if not(type(other[0])==type(other[1])==int):
                raise ValueError('Нужны целые числа')
            if not(other[0]>0 and other[1]>0): raise ValueError('Нужны целые числа')
            self.w, self.h = other
            self.__other = [[0]*self.w for i in range(self.h)]
        else:
            other=other[0]
            if len(other) == 0: raise ValueError('Нельзя создать матрицу из ничего')
            if not all(len(x) == len(other[0]) for x in other): raise ValueError('Другое количество элементов')
            self.w, self.h = len(other[0]), len(other)
            self.__other = [list(i) for i in other]
    get_m = lambda self: self.w
    get_n = lambda self: self.h
    get_size = lambda self: (self.w, self.h)
    is_square = lambda self: self.w == self.h
    def invert(self):
        if not self.is_square(): raise ValueError('Можно делать только с квадратной матрицей')
        if (self.w, self.h) == (2, 2):
            a, b, c, d = self.__other[0] + self.__other[1]
            det = a*d - b*c
            return Matrix(((d/det, -b/det), (-c/det, a/det)))
    def set(self,x, y, value):
        self.__other[y][x] = value
    def get(self, x, y):
        return self.__other[y][x]
    def transpose(self):
        return Matrix(list(zip(*self.__other)))
    def __str__(self):
        return '\n'.join(['('+', '.join([str(self.__other[i][j]) for j in range(self.w)])+')' for i in range(self.h)])
    def comparable(self, other):
        if type(other) != Matrix: raise ValueError('Можно сравнивать только матрицы, {} - это {}, а не матрица'.format(other, type(other)))
        return self.w == other.w and self.h == other.h
    def __eq__(self, other):
        if not self.comparable(other): raise ValueError('Нельзя сравнивать мтрицы разных размеров')
        return all(all(self.__other[i][j]==other.__other[i][j] for j in range(len(self.__other[0]))) for i in range(len(self.__other)))
    def __add__(self, other):
        if not self.comparable(other): raise ValueError('Нельзя складывать матрицы разного размера')
        return Matrix([[self.__other[i][j]+other.__other[i][j] for j in range(len(self.__other[0]))] for i in range(len(self.__other))])
    def __sub__(self, other):
        if not self.comparable(other): raise ValueError('Нельзя вычитать матрицы разного размера')
        return Matrix([[self.__other[i][j]-other.__other[i][j] for j in range(len(self.__other[0]))] for i in range(len(self.__other))])
    def __cross(self, x, y):
        return Matrix([row[:x]+row[x+1:] for row in self.__other[:y] + self.__other[y+1:]])
    def __mul__(self, other):
        if type(other) not in [int, float, Matrix]: raise ValueError('Нельзя матрицу умножить на это', type(other))
        if type(other) == Matrix:
            other, self = self, other
            if self.w != other.h: raise ValueError('Эти матрицы нельзя умножить')
            return Matrix([[sum(row1[i]*other.__other[i][col2_ind] for i in range(self.w)) for col2_ind in range(other.w)] for row1 in self.__ems])
        else:
            return Matrix([[self.__other[i][j]*other for j in range(self.w)] for i in range(self.h)])
    def __truediv__(self, other):
        if type(other) in [int, float]:
            return self * (1/other)
        else:
            raise ValueError()
    def determinant(self):
        if not self.is_square(): raise ValueError('Матрица не квадратная')
        if self.w == 1: return self.__other[0][0]
        else:
            return sum([(-1)**i * self.__other[0][i] * self.__cross(i, 0).determinant() for i in range(self.w)])
